using System;
using System.Collections.Generic;
using System.Linq;
using ConsoleApplication2.Test;
using System.Linq.Expressions;
using System.Text;
using System.Math;
using System.Diagnostics;
using ConsoleApplication2.Test;
using int1;
using ABC.X<int>;
using System.Math;
using System.DayOfWeek;
using System.Linq.Enumerable;

class TopLevelType
{
    void Dispose() { }
}namespace My.Moy
{
    using A.B;

    interface CoContra { }

    TODO DelegateDeclaration

    public unsafe partial class A
    {
        static extern bool CreateDirectory() { }

        private const int global = TODO SubtractExpression;

        static A()
        {
            TODO PostIncrementExpression.b().a;
            var x = TODO AddExpression;
            var y = TODO ConditionalExpression;
        }

        public A()
        {
            TODO LabeledStatement
            int? local = int.MaxValue;
            Guid? local0 = TODO ObjectCreationExpression;
            var ?????? = local;
            var ??? = local;
            var local3 = TODO NumericLiteralExpressionlocal4 = TODO NumericLiteralExpression;
            local3 = local4 = TODO NumericLiteralExpression;
            var local5 = TODO CoalesceExpression;
            var local6 = TODO IsExpression;
            string local7 = TODO DefaultLiteralExpression;
            var u = TODO NumericLiteralExpression;
            var U = TODO NumericLiteralExpression;
            long hex = TODO NumericLiteralExpressionHex = TODO NumericLiteralExpressionl = TODO UnaryMinusExpressionL = TODO NumericLiteralExpressionl2 = TODO NumericLiteralExpression;
            ulong ul = TODO NumericLiteralExpressionUl = TODO NumericLiteralExpressionuL = TODO NumericLiteralExpressionUL = TODO NumericLiteralExpressionlu = TODO NumericLiteralExpressionLu = TODO NumericLiteralExpressionlU = TODO NumericLiteralExpressionLU = TODO NumericLiteralExpression;
            int minInt32Value = TODO UnaryMinusExpression;
            int minInt64Value = TODO UnaryMinusExpression;
            bool @bool;
            byte @byte;
            char @char = TODO CharacterLiteralExpression\u0066 = TODO CharacterLiteralExpressionhexchar = TODO CharacterLiteralExpressionhexchar2 = TODO CastExpression;
            string \U00000065 = TODO StringLiteralExpression;
            decimal @decimal = TODO NumericLiteralExpression;
            @decimal = TODO NumericLiteralExpression;
            dynamic @dynamic;
            double @double = M.PI;
            @double = TODO NumericLiteralExpression;
            @double = TODO NumericLiteralExpression;
            @double = TODO UnaryMinusExpression;
            float @float = TODO NumericLiteralExpression;
            @float = TODO NumericLiteralExpression;
            int @int = TODO CoalesceExpression;
            long @long;
            object @object;
            sbyte @sbyte;
            short @short;
            string @string = TODO StringLiteralExpression;
            uint @uint;
            ulong @ulong;
            ushort @ushort;
            dynamic dynamic = local5;
            var add = TODO NumericLiteralExpression;
            var alias = TODO NumericLiteralExpression;
            var arglist = TODO NumericLiteralExpression;
            var ascending = TODO NumericLiteralExpression;
            var async = TODO NumericLiteralExpression;
            var await = TODO NumericLiteralExpression;
            var by = TODO NumericLiteralExpression;
            var descending = TODO NumericLiteralExpression;
            var dynamic = TODO NumericLiteralExpression;
            var equals = TODO NumericLiteralExpression;
            var from = TODO NumericLiteralExpression;
            var get = TODO NumericLiteralExpression;
            var group = TODO NumericLiteralExpression;
            var into = TODO NumericLiteralExpression;
            var join = TODO NumericLiteralExpression;
            var let = TODO NumericLiteralExpression;
            var nameof = TODO NumericLiteralExpression;
            var on = TODO NumericLiteralExpression;
            var orderby = TODO NumericLiteralExpression;
            var partial = TODO NumericLiteralExpression;
            var remove = TODO NumericLiteralExpression;
            var select = TODO NumericLiteralExpression;
            var set = TODO NumericLiteralExpression;
            var var = TODO NumericLiteralExpression;
            var when = TODO NumericLiteralExpression;
            var where = TODO NumericLiteralExpression;
            var yield = TODO NumericLiteralExpression;
            var __ = TODO NumericLiteralExpression;
            where = yield = TODO NumericLiteralExpression;
            TODO IfStatement
            var o1 = TODO ObjectCreationExpression;
            var o2 = TODO ObjectCreationExpression;
            var o3 = TODO ObjectCreationExpression;
            var o4 = TODO ObjectCreationExpression;
            var o5 = TODO AnonymousObjectCreationExpression;
            var dictionaryInitializer = TODO ObjectCreationExpression;
            TODO ArrayType a = TODO ArrayCreationExpression;
            TODO ArrayType cube = TODO ArrayInitializerExpression;
            TODO ArrayType jagged = TODO ArrayInitializerExpression;
            TODO ArrayType arr = TODO ArrayCreationExpression;
            TODO ElementAccessExpression = TODO ArrayCreationExpression;
            TODO ElementAccessExpression = TODO NumericLiteralExpression;
            TODO ArrayType arrayTypeInference = TODO ImplicitArrayCreationExpression;
            TODO SwitchStatement
            TODO SwitchStatement
            TODO SwitchStatement
            TODO WhileStatement
            TODO DoStatement
            TODO ForStatement
            TODO LabeledStatement
            TODO LabeledStatement
            TODO ForEachStatement
            TODO CheckedStatement
            TODO UncheckedStatement
            TODO LockStatement
            TODO UsingStatement
            TODO YieldReturnStatement
            TODO YieldBreakStatement
            TODO FixedStatement
            TODO FixedStatement
            TODO UnsafeStatement
            TODO TryStatement
            var anonymous = TODO ArrayInitializerExpression;
            var query = TODO QueryExpression;
            query = TODO QueryExpression;
        }

        TODO DestructorDeclaration

        private readonly int f1;

        private volatile int f2;

        public void Handler() { }

        public int m()
        {
            TODO BaseExpression.m(TODO Argument);
            return TODO NumericLiteralExpression;
        }

        public string P
        {
            get
            {
                return TODO StringLiteralExpression;
            }
            set;
        }

        public abstract string P { get; }

        TODO IndexerDeclaration

        TODO EventFieldDeclaration

        TODO EventDeclaration

        TODO OperatorDeclaration

        TODO OperatorDeclaration

        TODO OperatorDeclaration

        class C { }
    }

    TODO StructDeclaration

    public interface I
    {
        void A() { }

        string Value { get; set; }

        unsafe void UpdateSignatureByHashingContent() { }
    }

    TODO EnumDeclaration

    TODO DelegateDeclaration

    namespace Test
    {
        using System;
        using System.Collections;

        public class ??????
        {
            public static IEnumerable Power()
            {
                ?????? ?????? = TODO ObjectCreationExpression;
                ??????.Main();
                int counter = TODO ParenthesizedExpression;
                int ??? = TODO NumericLiteralExpression;
                TODO WhileStatement
            }

            static void Main()
            {
                TODO ForEachStatement
            }

            async void Wait()
            {
                TODO AwaitExpression;
            }

            void AsyncAnonymous()
            {
                var task = Task.Factory.StartNew(TODO Argument);
            }
        }
    }
}namespace ConsoleApplication1
{
    namespace RecursiveGenericBaseType
    {
        class A
        {
            protected virtual A<T> M() { }

            protected abstract B<A<T>, A<T>> N() { }

            static B<A<T>, A<T>> O() { }
        }

        sealed class B
        {
            protected override A<T> M() { }

            protected sealed override B<A<T>, A<T>> N() { }

            new static A<T> O() { }
        }
    }

    namespace Boo
    {
        public class Bar
        {
            public T f;

            public class Foo
            {
                public void Method()
                {
                    A<int> a;
                    M(TODO Argument);
                }
            }
        }
    }

    class Test
    {
        void Bar3()
        {
            var x = TODO ObjectCreationExpression;
            x.Method<string, string>(TODO Argument,
                TODO Argument,
                TODO Argument);
            var q = TODO QueryExpression;
        }

        TODO ConversionOperatorDeclaration

        TODO ConversionOperatorDeclaration

        public int foo = TODO NumericLiteralExpression;

        void Bar2()
        {
            foo = TODO NumericLiteralExpression;
            this.Foo = TODO NumericLiteralExpression.GetType();
            Test t = TODO StringLiteralExpression;
        }

        TODO EventFieldDeclaration

        void Blah()
        {
            int i = TODO NumericLiteralExpression;
            int? j = TODO NumericLiteralExpression;
            Expression<Func<int>> e = TODO ParenthesizedLambdaExpression;
            Expression<Func<bool, Action>> e2 = TODO SimpleLambdaExpression;
            Func<bool, bool> f = TODO AnonymousMethodExpression;
            Func<int, int, int> f2 = TODO ParenthesizedLambdaExpression;
            f2 = TODO ParenthesizedLambdaExpression;
            Action a = Blah;
            f2 = TODO ParenthesizedLambdaExpression;
            f2 = TODO ParenthesizedLambdaExpression;
        }

        TODO DelegateDeclaration

        TODO DelegateDeclaration

        public Type Foo
        {
            get
            {
                var result = TODO TypeOfExpression;
                var t = TODO EqualsExpression;
                t = TODO TypeOfExpression;
                return TODO TypeOfExpression;
            }
            set
            {
                var t = TODO TypeOfExpression;
                t.ToString();
                t = value;
            }
        }

        public void Constants()
        {
            int i = TODO AddExpression;
            TODO AliasQualifiedName.String s = TODO AddExpression;
        }

        public void ConstructedType()
        {
            List<int> i = TODO NullLiteralExpression;
            int c = i.Count;
        }

        class Foo
        {
            public int N;

            public void Dispose() { }
        }

        unsafe void EmptyEmbeddedStatment()
        {
            TODO EmptyStatement
            TODO IfStatement
            TODO WhileStatement
            TODO DoStatement
            TODO ForStatement
            TODO ForEachStatement
            TODO LockStatement
            TODO UsingStatement
            var o = TODO ObjectCreationExpression;
            TODO FixedStatement
        }
    }
}namespace Comments.XmlComments.UndocumentedKeywords
{
    class C
    {
        void M()
        {
            int intValue = TODO NumericLiteralExpression;
            intValue = TODO AddExpression;
            string strValue = TODO StringLiteralExpression;
            MyClass c = TODO ObjectCreationExpression;
            string verbatimStr = TODO StringLiteralExpression;
            int i = TODO AddExpression;
            i = TODO AddExpression;
            i = TODO ConditionalExpression;
        }
    }

    class TestClassXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX { }

    class TestClassXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX22 { }

    class yield
    {
        void Foo()
        {
            C<U> c = TODO NullLiteralExpression;
            c.M<int>(TODO Argument, TODO Argument);
            TypedReference tr = TODO MakeRefExpression;
            Type t = TODO RefTypeExpression;
            int j = TODO RefValueExpression;
            Params(TODO Argument, TODO Argument);
            Params(TODO Argument, TODO Argument);
            Params(TODO Argument, TODO Argument);
        }

        void Params() { }

        void Params() { }

        public override string ToString()
        {
            return TODO BaseExpression.ToString();
        }

        public partial void OnError() { }

        public partial void method()
        {
            TODO ArrayType a = TODO ArrayCreationExpression;
            TODO ArrayType var = TODO ArrayInitializerExpression;
            int i = TODO ElementAccessExpression;
            Foo<T> f = TODO ObjectCreationExpression;
            f.method();
            i = TODO BitwiseOrExpression;
            bool b = TODO BitwiseOrExpression;
            b = TODO LogicalNotExpression;
            i = TODO BitwiseNotExpression;
            b = TODO LogicalAndExpression;
            int? ii = TODO NumericLiteralExpression;
            int f = TODO ConditionalExpression;
            TODO PostIncrementExpression;
            TODO PostDecrementExpression;
            b = TODO LogicalOrExpression;
            TODO LeftShiftExpression;
            TODO RightShiftExpression;
            b = TODO LogicalAndExpression;
            TODO AddAssignmentExpression;
            TODO SubtractAssignmentExpression;
            TODO MultiplyAssignmentExpression;
            TODO DivideAssignmentExpression;
            TODO ModuloAssignmentExpression;
            TODO AndAssignmentExpression;
            TODO OrAssignmentExpression;
            TODO ExclusiveOrAssignmentExpression;
            TODO LeftShiftAssignmentExpression;
            TODO RightShiftAssignmentExpression;
            object s = TODO SimpleLambdaExpression;
            double d = TODO NumericLiteralExpression;
            TODO EmptyStatement
            Point point;
            TODO UnsafeStatement
            TODO AliasQualifiedName br = TODO NullLiteralExpression;
            TODO ElementAccessExpression = TODO NumericLiteralExpression;
            TODO ElementAccessExpression = TODO StringLiteralExpression;
        }

        TODO StructDeclaration
    }

    class CSharp6Features
    {
        public string First { get; set; }

        public string Last { get; set; }

        public string Third { get; }

        public string Fourth { get; }

        public Point Move() { }

        TODO OperatorDeclaration

        TODO ConversionOperatorDeclaration

        public void Print() { }

        public string Name => TODO AddExpression;

        TODO IndexerDeclaration

        private void NoOp() { }

        async void Test()
        {
            WriteLine(TODO Argument);
            WriteLine(TODO Argument);
            var range = Range(TODO Argument, TODO Argument);
            var even = range.Where(TODO Argument);
            int? length = TODO ConditionalAccessExpression;
            Customer first = TODO ConditionalAccessExpression;
            int length = TODO CoalesceExpression;
            int? first = TODO ConditionalAccessExpression;
            TODO ConditionalAccessExpression;
            string s = TODO InterpolatedStringExpression;
            s = TODO InterpolatedStringExpression;
            s = TODO InterpolatedStringExpression;
            s = TODO InterpolatedStringExpression;
            s = TODO InterpolatedStringExpression;
            Logging.Log.Error(TODO Argument);
            TODO IfStatement
            WriteLine(TODO Argument);
            var numbers = TODO ObjectCreationExpression;
            TODO LocalFunctionStatement
            TODO TryStatement
            Resource res = TODO NullLiteralExpression;
            TODO TryStatement
        }
    }

    class CSharp7Features
    {
        TODO TupleType Tuples()
        {
            int a;
            var foo = TODO TupleExpression;
            var unnamed = TODO TupleExpression;
            var named = TODO TupleExpression;
            TODO TupleType foo = TODO TupleExpression;
            TODO TupleType nullableMembers = TODO TupleExpression;
            TODO TupleType nestedTuple = TODO TupleExpression;
            TODO DeclarationExpression = Tuples(TODO Argument);
            TODO TupleExpression = TODO TupleExpression;
            return TODO TupleExpression;
        }

        int ThrowExpressionExample() { }

        class C
        {
            TODO OperatorDeclaration

            void ThrowBinaryExpression()
            {
                TODO ThrowStatement
            }
        }

        void IsPatternMatch()
        {
            TODO IfStatement
            TODO IfStatement
            TODO IfStatement
            TODO IfStatement
            TODO IfStatement
            TODO IfStatement
            TODO IfStatement
        }

        void UnmanagedConstraint() { }
    }
}namespace Empty {}
